package ratelimiter

import (
	"sync"
	"time"
)

// RateLimiter defines the interface for rate limiting implementations
type RateLimiter interface {
	// Allow returns true if the request is allowed, false otherwise
	Allow() bool
	
	// AllowN returns true if n requests are allowed, false otherwise
	AllowN(n int) bool
	
	// Wait blocks until the request is allowed
	Wait()
	
	// Close closes the rate limiter and releases resources
	Close() error
}

// TokenBucket implements a token bucket rate limiter
type TokenBucket struct {
	rate      float64       // tokens per second
	capacity  int           // maximum number of tokens
	tokens    float64       // current number of tokens
	lastRefill time.Time    // last time tokens were refilled
	mu        sync.Mutex
}

// NewTokenBucket creates a new token bucket rate limiter
func NewTokenBucket(requestsPerSecond, burst int) *TokenBucket {
	return &TokenBucket{
		rate:       float64(requestsPerSecond),
		capacity:   burst,
		tokens:     float64(burst),
		lastRefill: time.Now(),
	}
}

// Allow returns true if the request is allowed, false otherwise
func (tb *TokenBucket) Allow() bool {
	return tb.AllowN(1)
}

// AllowN returns true if n requests are allowed, false otherwise
func (tb *TokenBucket) AllowN(n int) bool {
	tb.mu.Lock()
	defer tb.mu.Unlock()
	
	tb.refill()
	
	if tb.tokens >= float64(n) {
		tb.tokens -= float64(n)
		return true
	}
	
	return false
}

// Wait blocks until the request is allowed
func (tb *TokenBucket) Wait() {
	for !tb.Allow() {
		// Calculate how long to wait for the next token
		tb.mu.Lock()
		waitTime := time.Duration(1.0/tb.rate*1000) * time.Millisecond
		tb.mu.Unlock()
		
		time.Sleep(waitTime)
	}
}

// Close closes the rate limiter and releases resources
func (tb *TokenBucket) Close() error {
	// Token bucket doesn't need cleanup
	return nil
}

// refill adds tokens to the bucket based on elapsed time
func (tb *TokenBucket) refill() {
	now := time.Now()
	elapsed := now.Sub(tb.lastRefill).Seconds()
	
	// Add tokens based on elapsed time
	tokensToAdd := elapsed * tb.rate
	tb.tokens += tokensToAdd
	
	// Cap at maximum capacity
	if tb.tokens > float64(tb.capacity) {
		tb.tokens = float64(tb.capacity)
	}
	
	tb.lastRefill = now
}