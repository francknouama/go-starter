package {{.ProjectName | replace "-" "_"}}

import (
	"context"
	"fmt"
	"testing"
	"time"
)

// BenchmarkClient_Process benchmarks the basic processing functionality
func BenchmarkClient_Process(b *testing.B) {
	client, err := New(WithDebug(false))
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	input := &Input{
		ID:        "benchmark-test",
		Data:      "benchmark data for testing performance",
		Timestamp: time.Now(),
	}

	ctx := context.Background()

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := client.Process(ctx, input)
			if err != nil {
				b.Errorf("Process failed: %v", err)
			}
		}
	})
}

// BenchmarkClient_ProcessWithCaching benchmarks processing with caching enabled
func BenchmarkClient_ProcessWithCaching(b *testing.B) {
	client, err := New(
		WithCaching(true, 5*time.Minute),
		WithDebug(false),
	)
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	input := &Input{
		ID:        "benchmark-cache-test",
		Data:      "benchmark data for caching performance",
		Timestamp: time.Now(),
	}

	ctx := context.Background()

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := client.Process(ctx, input)
			if err != nil {
				b.Errorf("Process failed: %v", err)
			}
		}
	})
}

// BenchmarkClient_ProcessBatch benchmarks batch processing
func BenchmarkClient_ProcessBatch(b *testing.B) {
	client, err := New(WithDebug(false))
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	// Create batch inputs
	batchSizes := []int{1, 10, 50, 100}

	for _, size := range batchSizes {
		b.Run(fmt.Sprintf("batch_size_%d", size), func(b *testing.B) {
			inputs := make([]*Input, size)
			for i := 0; i < size; i++ {
				inputs[i] = &Input{
					ID:        fmt.Sprintf("batch-item-%d", i),
					Data:      fmt.Sprintf("batch data item %d", i),
					Timestamp: time.Now(),
				}
			}

			ctx := context.Background()

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_, err := client.ProcessBatch(ctx, inputs)
				if err != nil {
					b.Errorf("ProcessBatch failed: %v", err)
				}
			}
		})
	}
}

// BenchmarkClient_Validate benchmarks input validation
func BenchmarkClient_Validate(b *testing.B) {
	client, err := New()
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	input := &Input{
		ID:        "validation-benchmark",
		Data:      "data for validation benchmarking",
		Timestamp: time.Now(),
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err := client.Validate(input)
		if err != nil {
			b.Errorf("Validate failed: %v", err)
		}
	}
}

// BenchmarkClient_ProcessDifferentSizes benchmarks processing with different input sizes
func BenchmarkClient_ProcessDifferentSizes(b *testing.B) {
	client, err := New(WithDebug(false))
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	sizes := []int{10, 100, 1000, 5000}

	for _, size := range sizes {
		b.Run(fmt.Sprintf("size_%d_bytes", size), func(b *testing.B) {
			input := &Input{
				ID:        fmt.Sprintf("size-test-%d", size),
				Data:      string(make([]byte, size)),
				Timestamp: time.Now(),
			}

			ctx := context.Background()

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_, err := client.Process(ctx, input)
				if err != nil {
					b.Errorf("Process failed: %v", err)
				}
			}
		})
	}
}

// BenchmarkClient_ConcurrentProcessing benchmarks concurrent processing
func BenchmarkClient_ConcurrentProcessing(b *testing.B) {
	client, err := New(
		WithRateLimit(1000, 100), // High limits for benchmarking
		WithDebug(false),
	)
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		i := 0
		for pb.Next() {
			input := &Input{
				ID:        fmt.Sprintf("concurrent-test-%d", i),
				Data:      fmt.Sprintf("concurrent data %d", i),
				Timestamp: time.Now(),
			}

			_, err := client.Process(ctx, input)
			if err != nil {
				b.Errorf("Process failed: %v", err)
			}
			i++
		}
	})
}

// BenchmarkMemoryAllocation benchmarks memory allocation patterns
func BenchmarkMemoryAllocation(b *testing.B) {
	client, err := New(WithDebug(false))
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		input := &Input{
			ID:        fmt.Sprintf("alloc-test-%d", i),
			Data:      "memory allocation test data",
			Timestamp: time.Now(),
			Metadata:  map[string]interface{}{"test": true},
		}

		output, err := client.Process(ctx, input)
		if err != nil {
			b.Errorf("Process failed: %v", err)
		}

		// Use the output to prevent optimization
		_ = output.Result
	}
}

// BenchmarkClient_Health benchmarks health check performance
func BenchmarkClient_Health(b *testing.B) {
	client, err := New(WithMetrics(true))
	if err != nil {
		b.Fatalf("Failed to create client: %v", err)
	}
	defer client.Close()

	ctx := context.Background()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := client.Health(ctx)
		if err != nil {
			b.Errorf("Health check failed: %v", err)
		}
	}
}

// BenchmarkOptions benchmarks different configuration options
func BenchmarkOptions(b *testing.B) {
	options := []struct {
		name string
		opts []Option
	}{
		{
			name: "default",
			opts: nil,
		},
		{
			name: "with_caching",
			opts: []Option{WithCaching(true, 5*time.Minute)},
		},
		{
			name: "with_metrics",
			opts: []Option{WithMetrics(true)},
		},
		{
			name: "with_retry",
			opts: []Option{WithRetryPolicy(5, time.Second)},
		},
		{
			name: "all_features",
			opts: []Option{
				WithCaching(true, 5*time.Minute),
				WithMetrics(true),
				WithRetryPolicy(3, 500*time.Millisecond),
				WithRateLimit(100, 10),
			},
		},
	}

	for _, opt := range options {
		b.Run(opt.name, func(b *testing.B) {
			client, err := New(opt.opts...)
			if err != nil {
				b.Fatalf("Failed to create client: %v", err)
			}
			defer client.Close()

			input := &Input{
				ID:        "options-benchmark",
				Data:      "options benchmark data",
				Timestamp: time.Now(),
			}

			ctx := context.Background()

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_, err := client.Process(ctx, input)
				if err != nil {
					b.Errorf("Process failed: %v", err)
				}
			}
		})
	}
}