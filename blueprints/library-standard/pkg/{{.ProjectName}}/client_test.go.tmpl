package {{.ProjectName | replace "-" "_"}}

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNew(t *testing.T) {
	tests := []struct {
		name    string
		opts    []Option
		wantErr bool
	}{
		{
			name:    "default config",
			opts:    nil,
			wantErr: false,
		},
		{
			name: "with timeout",
			opts: []Option{
				WithTimeout(10 * time.Second),
			},
			wantErr: false,
		},
		{
			name: "with debug enabled",
			opts: []Option{
				WithDebug(true),
			},
			wantErr: false,
		},
		{
			name: "with caching",
			opts: []Option{
				WithCaching(true, 5*time.Minute),
			},
			wantErr: false,
		},
		{
			name: "with rate limiting",
			opts: []Option{
				WithRateLimit(50, 5),
			},
			wantErr: false,
		},
		{
			name: "with retry policy",
			opts: []Option{
				WithRetryPolicy(5, 2*time.Second),
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			client, err := New(tt.opts...)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, client)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, client)
				
				// Clean up
				if client != nil {
					err := client.Close()
					assert.NoError(t, err)
				}
			}
		})
	}
}

func TestClient_Process(t *testing.T) {
	client, err := New(WithDebug(true))
	require.NoError(t, err)
	defer client.Close()

	tests := []struct {
		name    string
		input   *Input
		wantErr bool
		wantStatus ProcessingStatus
	}{
		{
			name: "valid input",
			input: &Input{
				ID:        "test-1",
				Data:      "hello world",
				Timestamp: time.Now(),
			},
			wantErr: false,
			wantStatus: StatusSuccess,
		},
		{
			name: "empty input data",
			input: &Input{
				ID:        "test-2",
				Data:      "",
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
		{
			name: "empty input ID",
			input: &Input{
				ID:        "",
				Data:      "test data",
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
		{
			name:    "nil input",
			input:   nil,
			wantErr: true,
		},
		{
			name: "input too large",
			input: &Input{
				ID:        "test-3",
				Data:      string(make([]byte, 15000)), // Exceeds 10000 byte limit
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
		{
			name: "error trigger",
			input: &Input{
				ID:        "test-4",
				Data:      "error", // Special value that triggers error
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			output, err := client.Process(ctx, tt.input)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, output)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, output)
				assert.Equal(t, tt.input.ID, output.ID)
				assert.Equal(t, tt.wantStatus, output.Status)
				assert.NotEmpty(t, output.Result)
				assert.Greater(t, output.ProcessingTime, time.Duration(0))
			}
		})
	}
}

func TestClient_ProcessBatch(t *testing.T) {
	client, err := New(WithDebug(true))
	require.NoError(t, err)
	defer client.Close()

	tests := []struct {
		name        string
		inputs      []*Input
		wantErr     bool
		expectedLen int
	}{
		{
			name:        "empty batch",
			inputs:      []*Input{},
			wantErr:     false,
			expectedLen: 0,
		},
		{
			name: "valid batch",
			inputs: []*Input{
				{ID: "batch-1", Data: "first", Timestamp: time.Now()},
				{ID: "batch-2", Data: "second", Timestamp: time.Now()},
				{ID: "batch-3", Data: "third", Timestamp: time.Now()},
			},
			wantErr:     false,
			expectedLen: 3,
		},
		{
			name: "mixed success and failure",
			inputs: []*Input{
				{ID: "batch-4", Data: "success", Timestamp: time.Now()},
				{ID: "batch-5", Data: "error", Timestamp: time.Now()}, // Will trigger error
				{ID: "batch-6", Data: "success2", Timestamp: time.Now()},
			},
			wantErr:     true, // Some items failed
			expectedLen: 3,    // But still returns all results
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			outputs, err := client.ProcessBatch(ctx, tt.inputs)

			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			assert.Len(t, outputs, tt.expectedLen)

			// Check that all outputs have corresponding inputs
			for i, output := range outputs {
				if i < len(tt.inputs) {
					assert.Equal(t, tt.inputs[i].ID, output.ID)
				}
			}
		})
	}
}

func TestClient_Validate(t *testing.T) {
	client, err := New()
	require.NoError(t, err)
	defer client.Close()

	tests := []struct {
		name    string
		input   *Input
		wantErr bool
	}{
		{
			name: "valid input",
			input: &Input{
				ID:        "test-1",
				Data:      "valid data",
				Timestamp: time.Now(),
			},
			wantErr: false,
		},
		{
			name:    "nil input",
			input:   nil,
			wantErr: true,
		},
		{
			name: "empty ID",
			input: &Input{
				ID:        "",
				Data:      "data",
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
		{
			name: "empty data",
			input: &Input{
				ID:        "test-2",
				Data:      "",
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
		{
			name: "data too large",
			input: &Input{
				ID:        "test-3",
				Data:      string(make([]byte, 15000)),
				Timestamp: time.Now(),
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := client.Validate(tt.input)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestClient_Health(t *testing.T) {
	client, err := New(WithMetrics(true))
	require.NoError(t, err)
	defer client.Close()

	ctx := context.Background()
	health, err := client.Health(ctx)

	assert.NoError(t, err)
	assert.NotNil(t, health)
	assert.Equal(t, "healthy", health.Status)
	assert.Equal(t, Version, health.Version)
	assert.Greater(t, health.Uptime, time.Duration(0))
	assert.NotNil(t, health.Metrics)
	assert.NotNil(t, health.Details)
}

func TestClient_HealthAfterClose(t *testing.T) {
	client, err := New()
	require.NoError(t, err)

	err = client.Close()
	require.NoError(t, err)

	ctx := context.Background()
	health, err := client.Health(ctx)

	assert.NoError(t, err)
	assert.NotNil(t, health)
	assert.Equal(t, "unhealthy", health.Status)
	assert.Contains(t, health.Details, "reason")
}

func TestClient_ProcessAfterClose(t *testing.T) {
	client, err := New()
	require.NoError(t, err)

	err = client.Close()
	require.NoError(t, err)

	input := &Input{
		ID:        "test-after-close",
		Data:      "test data",
		Timestamp: time.Now(),
	}

	ctx := context.Background()
	output, err := client.Process(ctx, input)

	assert.Error(t, err)
	assert.Equal(t, ErrClosed, err)
	assert.Nil(t, output)
}

func TestClient_WithCaching(t *testing.T) {
	client, err := New(
		WithCaching(true, 1*time.Minute),
		WithDebug(true),
	)
	require.NoError(t, err)
	defer client.Close()

	input := &Input{
		ID:        "cache-test",
		Data:      "cached data",
		Timestamp: time.Now(),
	}

	ctx := context.Background()

	// First call - should miss cache
	output1, err := client.Process(ctx, input)
	assert.NoError(t, err)
	assert.NotNil(t, output1)

	// Second call with same ID - should hit cache
	output2, err := client.Process(ctx, input)
	assert.NoError(t, err)
	assert.NotNil(t, output2)
	assert.Equal(t, output1.Result, output2.Result)
}

func TestClient_WithRateLimit(t *testing.T) {
	// Create client with very restrictive rate limit
	client, err := New(
		WithRateLimit(1, 1), // 1 request per second, burst of 1
		WithDebug(true),
	)
	require.NoError(t, err)
	defer client.Close()

	input1 := &Input{
		ID:        "rate-test-1",
		Data:      "first request",
		Timestamp: time.Now(),
	}

	input2 := &Input{
		ID:        "rate-test-2",
		Data:      "second request",
		Timestamp: time.Now(),
	}

	ctx := context.Background()

	// First request should succeed
	output1, err := client.Process(ctx, input1)
	assert.NoError(t, err)
	assert.NotNil(t, output1)

	// Second request should be rate limited
	output2, err := client.Process(ctx, input2)
	assert.Error(t, err)
	assert.Equal(t, ErrRateLimitExceeded, err)
	assert.Nil(t, output2)
}

func TestClient_WithTimeout(t *testing.T) {
	// This test would require a way to simulate slow processing
	// For now, we just test that the timeout option is accepted
	client, err := New(WithTimeout(100 * time.Millisecond))
	require.NoError(t, err)
	defer client.Close()

	assert.Equal(t, 100*time.Millisecond, client.config.Timeout)
}

func TestClient_WithCallback(t *testing.T) {
	var events []Event
	callback := func(event Event) {
		events = append(events, event)
	}

	client, err := New(
		WithCallback(callback),
		WithDebug(true),
	)
	require.NoError(t, err)
	defer client.Close()

	input := &Input{
		ID:        "callback-test",
		Data:      "test data",
		Timestamp: time.Now(),
	}

	ctx := context.Background()
	_, err = client.Process(ctx, input)
	assert.NoError(t, err)

	// Give callbacks time to execute
	time.Sleep(100 * time.Millisecond)

	// Should have received events
	assert.Greater(t, len(events), 0)

	// Should include processing started and completed events
	hasStarted := false
	hasCompleted := false
	for _, event := range events {
		if event.Type == EventProcessingStarted {
			hasStarted = true
		}
		if event.Type == EventProcessingCompleted {
			hasCompleted = true
		}
	}
	assert.True(t, hasStarted)
	assert.True(t, hasCompleted)
}

func TestDefaultConfig(t *testing.T) {
	config := DefaultConfig()
	assert.NotNil(t, config)
	assert.False(t, config.Debug)
	assert.Equal(t, 30*time.Second, config.Timeout)
	assert.Equal(t, "warn", config.Logger.Level)
	assert.Equal(t, "text", config.Logger.Format)
	assert.Equal(t, 3, config.Retry.MaxRetries)
	assert.Equal(t, time.Second, config.Retry.Backoff)
	assert.False(t, config.Cache.Enabled)
	assert.Equal(t, 5*time.Minute, config.Cache.TTL)
	assert.Equal(t, 100, config.RateLimit.RequestsPerSecond)
	assert.Equal(t, 10, config.RateLimit.Burst)
	assert.True(t, config.Metrics.Enabled)
}

func TestError_WithDetails(t *testing.T) {
	err := ErrInvalidInput.WithDetails(map[string]interface{}{
		"field": "data",
		"value": "",
	})

	assert.Contains(t, err.Details, "field")
	assert.Contains(t, err.Details, "value")
	assert.Equal(t, "data", err.Details["field"])
	assert.Equal(t, "", err.Details["value"])
}